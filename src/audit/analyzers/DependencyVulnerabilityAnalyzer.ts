// Dependency Vulnerability Analysis Module

import { DependencyVulnerability, DependencySecurityReport } from '../types/index.js';
import { AuditError } from '../errors/AuditError.js';
import * as fs from 'fs/promises';
import * as path from 'path';
import { execSync } from 'child_process';

export interface PackageInfo {
  name: string;
  version: string;
  location: string;
  isDirect: boolean;
  isDevDependency: boolean;
  licenses: string[];
  vulnerabilities: DependencyVulnerability[];
}

export interface VulnerabilityDatabase {
  [packageName: string]: {
    [version: string]: DependencyVulnerability[];
  };
}

export class DependencyVulnerabilityAnalyzer {
  private packageJsonPath: string;
  private lockfilePath: string;
  private vulnerabilityDb: VulnerabilityDatabase = {};

  constructor(
    packageJsonPath: string = './package.json',
    lockfilePath: string = './package-lock.json'
  ) {
    this.packageJsonPath = packageJsonPath;
    this.lockfilePath = lockfilePath;
    this.initializeVulnerabilityDatabase();
  }

  /**
   * Initialize vulnerability database with known vulnerabilities
   */
  private initializeVulnerabilityDatabase(): void {
    // This would typically be loaded from a real vulnerability database
    // For demo purposes, we'll include some common vulnerabilities
    this.vulnerabilityDb = {
      'lodash': {
        '4.17.20': [{
          id: 'CVE-2021-23337',
          severity: 'HIGH',
          title: 'Command Injection in lodash',
          description: 'lodash versions prior to 4.17.21 are vulnerable to Command Injection via template.',
          packageName: 'lodash',
          vulnerableVersions: '<4.17.21',
          patchedVersions: '>=4.17.21',
          publishedDate: new Date('2021-02-15'),
          references: ['https://nvd.nist.gov/vuln/detail/CVE-2021-23337'],
          cwe: 'CWE-77',
          cvssScore: 7.2,
          recommendation: 'Upgrade to lodash version 4.17.21 or later'
        }]
      },
      'axios': {
        '0.21.0': [{
          id: 'CVE-2021-3749',
          severity: 'MEDIUM',
          title: 'Regular Expression Denial of Service in axios',
          description: 'axios is vulnerable to Inefficient Regular Expression Complexity.',
          packageName: 'axios',
          vulnerableVersions: '>=0.8.1 <0.21.2',
          patchedVersions: '>=0.21.2',
          publishedDate: new Date('2021-08-31'),
          references: ['https://nvd.nist.gov/vuln/detail/CVE-2021-3749'],
          cwe: 'CWE-1333',
          cvssScore: 5.3,
          recommendation: 'Upgrade to axios version 0.21.2 or later'
        }]
      },
      'express': {
        '4.17.0': [{
          id: 'CVE-2022-24999',
          severity: 'MEDIUM',
          title: 'qs vulnerable to Prototype Pollution',
          description: 'Express.js minimist qs vulnerable to Prototype Pollution.',
          packageName: 'express',
          vulnerableVersions: '<4.17.3',
          patchedVersions: '>=4.17.3',
          publishedDate: new Date('2022-03-25'),
          references: ['https://nvd.nist.gov/vuln/detail/CVE-2022-24999'],
          cwe: 'CWE-1321',
          cvssScore: 5.6,
          recommendation: 'Upgrade to express version 4.17.3 or later'
        }]
      }
    };
  }

  /**
   * Read and parse package.json
   */
  private async readPackageJson(): Promise<any> {
    try {
      const content = await fs.readFile(this.packageJsonPath, 'utf-8');
      return JSON.parse(content);
    } catch (error) {
      throw new AuditError(
        `Failed to read package.json: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'SECURITY',
        'HIGH',
        'Ensure package.json exists and is valid JSON'
      );
    }
  }

  /**
   * Read and parse package-lock.json or yarn.lock
   */
  private async readLockfile(): Promise<any> {
    try {
      // Try package-lock.json first
      if (await this.fileExists(this.lockfilePath)) {
        const content = await fs.readFile(this.lockfilePath, 'utf-8');
        return JSON.parse(content);
      }

      // Try yarn.lock
      const yarnLockPath = './yarn.lock';
      if (await this.fileExists(yarnLockPath)) {
        // For yarn.lock, we'd need a parser, but for simplicity we'll skip
        return null;
      }

      return null;
    } catch (error) {
      // Lockfile is optional, so we don't throw an error
      return null;
    }
  }

  /**
   * Check if file exists
   */
  private async fileExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Extract package information from package.json and lockfile
   */
  private async extractPackageInfo(): Promise<PackageInfo[]> {
    const packageJson = await this.readPackageJson();
    const lockfile = await this.readLockfile();
    const packages: PackageInfo[] = [];

    // Process direct dependencies
    if (packageJson.dependencies) {
      for (const [name, version] of Object.entries(packageJson.dependencies)) {
        const packageInfo = await this.createPackageInfo(
          name,
          version as string,
          lockfile,
          true,
          false
        );
        packages.push(packageInfo);
      }
    }

    // Process dev dependencies
    if (packageJson.devDependencies) {
      for (const [name, version] of Object.entries(packageJson.devDependencies)) {
        const packageInfo = await this.createPackageInfo(
          name,
          version as string,
          lockfile,
          true,
          true
        );
        packages.push(packageInfo);
      }
    }

    // Process transitive dependencies from lockfile
    if (lockfile && lockfile.dependencies) {
      for (const [name, info] of Object.entries(lockfile.dependencies)) {
        const depInfo = info as any;
        if (!packages.find(p => p.name === name)) {
          const packageInfo = await this.createPackageInfo(
            name,
            depInfo.version,
            lockfile,
            false,
            false
          );
          packages.push(packageInfo);
        }
      }
    }

    return packages;
  }

  /**
   * Create package info object
   */
  private async createPackageInfo(
    name: string,
    version: string,
    lockfile: any,
    isDirect: boolean,
    isDevDependency: boolean
  ): Promise<PackageInfo> {
    // Get actual version from lockfile if available
    let actualVersion = version;
    let location = '';

    if (lockfile && lockfile.dependencies && lockfile.dependencies[name]) {
      actualVersion = lockfile.dependencies[name].version;
      location = lockfile.dependencies[name].resolved || '';
    }

    // Clean version string (remove ^ ~ etc.)
    const cleanVersion = actualVersion.replace(/^[\^~]/, '');

    // Check for vulnerabilities
    const vulnerabilities = this.checkVulnerabilities(name, cleanVersion);

    // Get licenses (simplified - would normally parse from node_modules)
    const licenses = await this.getLicenses(name);

    return {
      name,
      version: cleanVersion,
      location,
      isDirect,
      isDevDependency,
      licenses,
      vulnerabilities
    };
  }

  /**
   * Check for vulnerabilities in a specific package version
   */
  private checkVulnerabilities(packageName: string, version: string): DependencyVulnerability[] {
    const packageVulns = this.vulnerabilityDb[packageName];
    if (!packageVulns) {
      return [];
    }

    const vulnerabilities: DependencyVulnerability[] = [];

    for (const [vulnVersion, vulns] of Object.entries(packageVulns)) {
      // Simple version comparison (in real implementation, use semver)
      if (this.isVersionVulnerable(version, vulnVersion)) {
        vulnerabilities.push(...vulns);
      }
    }

    return vulnerabilities;
  }

  /**
   * Simple version vulnerability check
   */
  private isVersionVulnerable(currentVersion: string, vulnerableVersion: string): boolean {
    // This is a simplified version check
    // In a real implementation, you'd use semver for proper version comparison
    return currentVersion === vulnerableVersion || 
           currentVersion.startsWith(vulnerableVersion.split('.')[0]);
  }

  /**
   * Get package licenses (simplified)
   */
  private async getLicenses(packageName: string): Promise<string[]> {
    try {
      // In a real implementation, this would read from node_modules/package/package.json
      // For demo purposes, return common licenses
      const commonLicenses: { [key: string]: string[] } = {
        'lodash': ['MIT'],
        'axios': ['MIT'],
        'express': ['MIT'],
        'react': ['MIT'],
        'typescript': ['Apache-2.0']
      };

      return commonLicenses[packageName] || ['Unknown'];
    } catch {
      return ['Unknown'];
    }
  }

  /**
   * Run npm audit command
   */
  private async runNpmAudit(): Promise<any> {
    try {
      const output = execSync('npm audit --json', { 
        encoding: 'utf-8',
        cwd: path.dirname(this.packageJsonPath)
      });
      return JSON.parse(output);
    } catch (error) {
      // npm audit returns non-zero exit code when vulnerabilities are found
      if (error instanceof Error && 'stdout' in error) {
        try {
          return JSON.parse((error as any).stdout);
        } catch {
          // If we can't parse the output, return null
          return null;
        }
      }
      return null;
    }
  }

  /**
   * Parse npm audit results
   */
  private parseNpmAuditResults(auditResults: any): DependencyVulnerability[] {
    if (!auditResults || !auditResults.vulnerabilities) {
      return [];
    }

    const vulnerabilities: DependencyVulnerability[] = [];

    for (const [packageName, vulnInfo] of Object.entries(auditResults.vulnerabilities)) {
      const info = vulnInfo as any;
      
      if (info.via && Array.isArray(info.via)) {
        for (const via of info.via) {
          if (typeof via === 'object' && via.title) {
            vulnerabilities.push({
              id: via.cve || via.ghsa || `npm-${Date.now()}`,
              severity: this.mapNpmSeverity(via.severity),
              title: via.title,
              description: via.overview || via.title,
              packageName,
              vulnerableVersions: via.range || 'Unknown',
              patchedVersions: 'See recommendation',
              publishedDate: new Date(via.created || Date.now()),
              references: via.references || [],
              cwe: via.cwe || 'Unknown',
              cvssScore: via.cvss?.score || 0,
              recommendation: `Update ${packageName} to a patched version`
            });
          }
        }
      }
    }

    return vulnerabilities;
  }

  /**
   * Map npm audit severity to our severity levels
   */
  private mapNpmSeverity(npmSeverity: string): DependencyVulnerability['severity'] {
    switch (npmSeverity?.toLowerCase()) {
      case 'critical': return 'CRITICAL';
      case 'high': return 'HIGH';
      case 'moderate': return 'MEDIUM';
      case 'low': return 'LOW';
      default: return 'MEDIUM';
    }
  }

  /**
   * Check dependency vulnerabilities
   */
  async checkDependencyVulnerabilities(): Promise<DependencySecurityReport> {
    try {
      // Extract package information
      const packages = await this.extractPackageInfo();

      // Run npm audit if available
      const npmAuditResults = await this.runNpmAudit();
      const npmVulnerabilities = npmAuditResults ? 
        this.parseNpmAuditResults(npmAuditResults) : [];

      // Combine vulnerabilities from our database and npm audit
      const allVulnerabilities: DependencyVulnerability[] = [];
      
      // Add vulnerabilities from our database
      for (const pkg of packages) {
        allVulnerabilities.push(...pkg.vulnerabilities);
      }

      // Add vulnerabilities from npm audit
      allVulnerabilities.push(...npmVulnerabilities);

      // Remove duplicates
      const uniqueVulnerabilities = this.deduplicateVulnerabilities(allVulnerabilities);

      // Calculate statistics
      const totalPackages = packages.length;
      const vulnerablePackages = packages.filter(p => p.vulnerabilities.length > 0).length;
      const directVulnerable = packages.filter(p => p.isDirect && p.vulnerabilities.length > 0).length;
      const devVulnerable = packages.filter(p => p.isDevDependency && p.vulnerabilities.length > 0).length;

      const criticalCount = uniqueVulnerabilities.filter(v => v.severity === 'CRITICAL').length;
      const highCount = uniqueVulnerabilities.filter(v => v.severity === 'HIGH').length;
      const mediumCount = uniqueVulnerabilities.filter(v => v.severity === 'MEDIUM').length;
      const lowCount = uniqueVulnerabilities.filter(v => v.severity === 'LOW').length;

      // Determine risk level
      let riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' = 'LOW';
      if (criticalCount > 0) riskLevel = 'CRITICAL';
      else if (highCount > 2) riskLevel = 'HIGH';
      else if (highCount > 0 || mediumCount > 5) riskLevel = 'MEDIUM';

      // Generate recommendations
      const recommendations: string[] = [];
      
      if (criticalCount > 0) {
        recommendations.push(`Address ${criticalCount} critical vulnerabilities immediately`);
      }
      if (highCount > 0) {
        recommendations.push(`Fix ${highCount} high-severity vulnerabilities`);
      }
      if (directVulnerable > 0) {
        recommendations.push(`Update ${directVulnerable} vulnerable direct dependencies`);
      }
      if (uniqueVulnerabilities.length > 0) {
        recommendations.push('Run npm audit fix to automatically fix vulnerabilities where possible');
      }

      // Get outdated packages
      const outdatedPackages = await this.getOutdatedPackages(packages);

      return {
        vulnerabilities: uniqueVulnerabilities,
        packages,
        riskLevel,
        statistics: {
          totalPackages,
          vulnerablePackages,
          directVulnerable,
          devVulnerable,
          criticalCount,
          highCount,
          mediumCount,
          lowCount,
          outdatedPackages: outdatedPackages.length
        },
        outdatedPackages,
        recommendations,
        auditSource: npmAuditResults ? 'npm-audit' : 'internal-db',
        timestamp: new Date()
      };

    } catch (error) {
      if (error instanceof AuditError) {
        throw error;
      }
      throw new AuditError(
        `Dependency vulnerability check failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'SECURITY',
        'HIGH',
        'Check package.json and npm installation'
      );
    }
  }

  /**
   * Remove duplicate vulnerabilities
   */
  private deduplicateVulnerabilities(vulnerabilities: DependencyVulnerability[]): DependencyVulnerability[] {
    const seen = new Set<string>();
    return vulnerabilities.filter(vuln => {
      const key = `${vuln.id}-${vuln.packageName}`;
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  }

  /**
   * Get outdated packages
   */
  private async getOutdatedPackages(packages: PackageInfo[]): Promise<Array<{
    name: string;
    current: string;
    wanted: string;
    latest: string;
  }>> {
    try {
      const output = execSync('npm outdated --json', { 
        encoding: 'utf-8',
        cwd: path.dirname(this.packageJsonPath)
      });
      const outdated = JSON.parse(output);
      
      return Object.entries(outdated).map(([name, info]: [string, any]) => ({
        name,
        current: info.current,
        wanted: info.wanted,
        latest: info.latest
      }));
    } catch {
      // npm outdated returns non-zero exit code when packages are outdated
      // For simplicity, return empty array
      return [];
    }
  }

  /**
   * Assess vulnerability severity
   */
  assessVulnerabilitySeverity(vulnerabilities: DependencyVulnerability[]): {
    overallRisk: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    priorityVulnerabilities: DependencyVulnerability[];
    recommendations: string[];
  } {
    const criticalVulns = vulnerabilities.filter(v => v.severity === 'CRITICAL');
    const highVulns = vulnerabilities.filter(v => v.severity === 'HIGH');
    const mediumVulns = vulnerabilities.filter(v => v.severity === 'MEDIUM');

    let overallRisk: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' = 'LOW';
    if (criticalVulns.length > 0) overallRisk = 'CRITICAL';
    else if (highVulns.length > 2) overallRisk = 'HIGH';
    else if (highVulns.length > 0 || mediumVulns.length > 5) overallRisk = 'MEDIUM';

    // Priority vulnerabilities (critical and high)
    const priorityVulnerabilities = [...criticalVulns, ...highVulns];

    const recommendations: string[] = [];
    
    if (criticalVulns.length > 0) {
      recommendations.push('Immediately update packages with critical vulnerabilities');
    }
    if (highVulns.length > 0) {
      recommendations.push('Schedule updates for packages with high-severity vulnerabilities');
    }
    if (priorityVulnerabilities.length > 0) {
      recommendations.push('Consider using npm audit fix or yarn audit fix');
    }

    return {
      overallRisk,
      priorityVulnerabilities,
      recommendations
    };
  }
}