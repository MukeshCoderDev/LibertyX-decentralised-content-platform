// Dependency Vulnerability Analyzer Tests

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { DependencyVulnerabilityAnalyzer } from '../src/audit/analyzers/DependencyVulnerabilityAnalyzer.js';
import { AuditError } from '../src/audit/errors/AuditError.js';

// Mock modules
vi.mock('fs/promises', () => ({
  readFile: vi.fn(),
  access: vi.fn()
}));

vi.mock('child_process', async (importOriginal) => {
  const actual = await importOriginal();
  return {
    ...actual,
    execSync: vi.fn()
  };
});

describe('DependencyVulnerabilityAnalyzer', () => {
  let analyzer: DependencyVulnerabilityAnalyzer;
  let mockReadFile: any;
  let mockAccess: any;
  let mockExecSync: any;

  beforeEach(() => {
    analyzer = new DependencyVulnerabilityAnalyzer();
    
    // Get mock references
    mockReadFile = require('fs/promises').readFile;
    mockAccess = require('fs/promises').access;
    mockExecSync = require('child_process').execSync;
    
    vi.clearAllMocks();
  });

  describe('checkDependencyVulnerabilities', () => {
    it('should check dependencies with no vulnerabilities', async () => {
      const mockPackageJson = {
        dependencies: {
          'safe-package': '^1.0.0'
        }
      };

      mockReadFile.mockResolvedValueOnce(JSON.stringify(mockPackageJson));
      mockAccess.mockRejectedValue(new Error('No lockfile'));
      mockExecSync.mockReturnValue('{"vulnerabilities": {}}');

      const result = await analyzer.checkDependencyVulnerabilities();

      expect(result.vulnerabilities).toHaveLength(0);
      expect(result.riskLevel).toBe('LOW');
      expect(result.statistics.totalPackages).toBe(1);
      expect(result.timestamp).toBeInstanceOf(Date);
    });

    it('should detect vulnerabilities in known packages', async () => {
      const mockPackageJson = {
        dependencies: {
          'lodash': '^4.17.20'
        }
      };

      const mockLockfile = {
        dependencies: {
          'lodash': {
            version: '4.17.20'
          }
        }
      };

      mockReadFile
        .mockResolvedValueOnce(JSON.stringify(mockPackageJson))
        .mockResolvedValueOnce(JSON.stringify(mockLockfile));
      mockAccess.mockResolvedValue(undefined);
      mockExecSync.mockReturnValue('{"vulnerabilities": {}}');

      const result = await analyzer.checkDependencyVulnerabilities();

      expect(result.vulnerabilities.length).toBeGreaterThan(0);
      expect(result.riskLevel).not.toBe('LOW');
      
      // Check for lodash vulnerability
      const lodashVuln = result.vulnerabilities.find(v => v.packageName === 'lodash');
      expect(lodashVuln).toBeDefined();
      expect(lodashVuln?.severity).toBe('HIGH');
    });

    it('should handle missing package.json', async () => {
      mockReadFile.mockRejectedValue(new Error('File not found'));

      await expect(analyzer.checkDependencyVulnerabilities()).rejects.toThrow(AuditError);
    });

    it('should handle invalid package.json', async () => {
      mockReadFile.mockResolvedValue('invalid json');

      await expect(analyzer.checkDependencyVulnerabilities()).rejects.toThrow(AuditError);
    });

    it('should work without lockfile', async () => {
      const mockPackageJson = {
        dependencies: {
          'test-package': '^1.0.0'
        }
      };

      mockReadFile.mockResolvedValueOnce(JSON.stringify(mockPackageJson));
      mockAccess.mockRejectedValue(new Error('No lockfile'));
      mockExecSync.mockReturnValue('{"vulnerabilities": {}}');

      const result = await analyzer.checkDependencyVulnerabilities();

      expect(result).toBeDefined();
      expect(result.statistics.totalPackages).toBe(1);
    });

    it('should handle npm audit results', async () => {
      const mockPackageJson = {
        dependencies: {
          'vulnerable-package': '^1.0.0'
        }
      };

      const mockNpmAuditOutput = {
        vulnerabilities: {
          'vulnerable-package': {
            via: [{
              title: 'Test Vulnerability',
              severity: 'high',
              overview: 'Test vulnerability description',
              cve: 'CVE-2023-12345'
            }]
          }
        }
      };

      mockReadFile.mockResolvedValueOnce(JSON.stringify(mockPackageJson));
      mockAccess.mockRejectedValue(new Error('No lockfile'));
      mockExecSync.mockReturnValue(JSON.stringify(mockNpmAuditOutput));

      const result = await analyzer.checkDependencyVulnerabilities();

      expect(result.vulnerabilities.length).toBeGreaterThan(0);
      expect(result.auditSource).toBe('npm-audit');
    });

    it('should calculate risk levels correctly', async () => {
      const mockPackageJson = {
        dependencies: {
          'lodash': '^4.17.20',
          'axios': '^0.21.0'
        }
      };

      const mockLockfile = {
        dependencies: {
          'lodash': { version: '4.17.20' },
          'axios': { version: '0.21.0' }
        }
      };

      mockReadFile
        .mockResolvedValueOnce(JSON.stringify(mockPackageJson))
        .mockResolvedValueOnce(JSON.stringify(mockLockfile));
      mockAccess.mockResolvedValue(undefined);
      mockExecSync.mockReturnValue('{"vulnerabilities": {}}');

      const result = await analyzer.checkDependencyVulnerabilities();

      expect(result.riskLevel).not.toBe('LOW');
      expect(result.statistics.highCount).toBeGreaterThan(0);
    });
  });

  describe('assessVulnerabilitySeverity', () => {
    it('should assess vulnerability severity correctly', () => {
      const vulnerabilities = [
        {
          id: 'CVE-1',
          severity: 'CRITICAL' as const,
          title: 'Critical Vuln',
          description: 'Critical vulnerability',
          packageName: 'test-pkg',
          vulnerableVersions: '1.0.0',
          patchedVersions: '1.0.1',
          publishedDate: new Date(),
          references: [],
          cwe: 'CWE-79',
          cvssScore: 9.8,
          recommendation: 'Update immediately'
        }
      ];

      const assessment = analyzer.assessVulnerabilitySeverity(vulnerabilities);

      expect(assessment.overallRisk).toBe('CRITICAL');
      expect(assessment.priorityVulnerabilities).toHaveLength(1);
      expect(assessment.recommendations.length).toBeGreaterThan(0);
    });

    it('should handle empty vulnerability list', () => {
      const assessment = analyzer.assessVulnerabilitySeverity([]);

      expect(assessment.overallRisk).toBe('LOW');
      expect(assessment.priorityVulnerabilities).toHaveLength(0);
      expect(assessment.recommendations).toHaveLength(0);
    });
  });

  describe('vulnerability database', () => {
    it('should have initialized vulnerability database', () => {
      const db = analyzer['vulnerabilityDb'];
      
      expect(typeof db).toBe('object');
      expect(db['lodash']).toBeDefined();
      expect(db['axios']).toBeDefined();
      expect(db['express']).toBeDefined();
      
      // Check structure
      const lodashVulns = db['lodash']['4.17.20'];
      expect(Array.isArray(lodashVulns)).toBe(true);
      expect(lodashVulns[0]).toHaveProperty('id');
      expect(lodashVulns[0]).toHaveProperty('severity');
      expect(lodashVulns[0]).toHaveProperty('title');
    });
  });

  describe('error handling', () => {
    it('should handle file system errors gracefully', async () => {
      mockReadFile.mockRejectedValue(new Error('Permission denied'));

      await expect(analyzer.checkDependencyVulnerabilities()).rejects.toThrow(AuditError);
    });

    it('should handle npm command failures gracefully', async () => {
      const mockPackageJson = { dependencies: {} };

      mockReadFile.mockResolvedValueOnce(JSON.stringify(mockPackageJson));
      mockAccess.mockRejectedValue(new Error('No lockfile'));
      mockExecSync.mockImplementation(() => {
        throw new Error('npm not found');
      });

      const result = await analyzer.checkDependencyVulnerabilities();

      expect(result).toBeDefined();
      expect(result.auditSource).toBe('internal-db');
    });
  });
});